/**
 * This ruleset enforces a Role-Based Access Control (RBAC) model for a Human Resources (HR) system.
 *
 * Core Philosophy:
 * The security model is centered around a privileged 'Admin' role. Users with this role have
 * comprehensive create, read, update, and delete (CRUD) permissions across the entire database.
 * Standard users (employees) have limited, self-service access to their own data. The default
 * security posture is to deny all access unless explicitly granted by a role or ownership rule.
 *
 * Data Structure:
 * The database segregates administrative data from employee-specific data.
 * - /roles_admin/{userId}: A lookup collection to identify users with administrative privileges.
 * - /departments/{departmentId}: A top-level collection for company departments, managed exclusively by admins.
 * - /employees/{employeeId}: A top-level collection for employee profiles.
 * - Subcollections under /employees/{employeeId} (e.g., attendanceRecords, payrollRecords) store data
 *   owned by and directly related to a specific employee, enabling path-based security.
 *
 * Key Security Decisions:
 * - Admin Supremacy: The existence of a user's UID in the /roles_admin collection grants them
 *   full access to all data, ensuring comprehensive management capabilities.
 * - Strict Employee Self-Access: An employee's access is strictly confined to their own document tree
 *   (i.e., `/employees/{their-own-id}/...`). The document ID `{employeeId}` is assumed to be the
 *   same as the user's Firebase Authentication UID.
 * - No User Listing: Non-admin users are prohibited from listing documents in top-level collections
 *   like `/employees` or `/departments` to protect user privacy and company structure information.
 * - Write Integrity: On creation, documents must contain an ID field that matches their document ID
 *   in the path, ensuring relational integrity. This ID is immutable upon update.
 *
 * Denormalization for Authorization:
 * The `/roles_admin/{userId}` collection is a prime example of denormalization for authorization.
 * Instead of checking a field on a user profile, we use a simple and performant `exists()` call
 * to this dedicated collection to determine a user's role, which simplifies rules throughout the system.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the requesting user is an administrator by checking for their
     * UID in the dedicated admin roles collection.
     */
    function isAdmin() {
      return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Checks if the document ID matches the requesting user's UID.
     * This is the primary function for enforcing data ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    /**
     * Provides a contextually named alias for isOwner in the context of employees.
     */
    function isEmployee(employeeId) {
        return isOwner(employeeId);
    }
    
    /**
     * Validates that the internal 'id' field of a document being created
     * matches the document's ID in the path.
     */
    function hasMatchingIdOnCreate(docId) {
        return request.resource.data.id == docId;
    }

    /**
     * Validates that the internal 'employeeId' field of a subcollection document
     * being created matches the parent employee's ID in the path.
     */
    function hasMatchingEmployeeIdOnCreate(employeeId) {
        return request.resource.data.employeeId == employeeId;
    }

    /**
     * Enforces immutability of the internal 'employeeId' field during updates.
     */
    function employeeIdIsImmutable() {
        return request.resource.data.employeeId == resource.data.employeeId;
    }

    // ------------------------------------------------------------------------
    // Admin & System Rules
    // ------------------------------------------------------------------------

    /**
     * @description Manages admin role assignments. Only existing admins can view or modify this list.
     * @path /roles_admin/{userId}
     * @allow An admin (auth.uid='admin_abc') can read, create, or delete another user's admin status doc (e.g., /roles_admin/user_xyz).
     * @deny A non-admin user (auth.uid='user_123') cannot read or write to any document in this collection.
     * @principle Enforces hierarchical role management; prevents self-promotion to admin status.
     */
    match /roles_admin/{userId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    /**
     * @description Manages company department information. This collection is for admin use only.
     * @path /departments/{departmentId}
     * @allow An admin can (create) a new department document.
     * @deny A regular employee cannot (list) or (get) any department information.
     * @principle Restricts management of core company structure to authorized administrators.
     */
    match /departments/{departmentId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin() && hasMatchingIdOnCreate(departmentId);
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    // ------------------------------------------------------------------------
    // Employee Data Rules
    // ------------------------------------------------------------------------

    /**
     * @description Manages core employee profiles. Admins have full control. Employees can read and update their own profile.
     * @path /employees/{employeeId}
     * @allow An employee (auth.uid='emp_123') can (get) their own document at /employees/emp_123.
     * @deny A regular employee (auth.uid='emp_123') cannot (list) all employees or (delete) their own profile.
     * @principle Combines role-based admin access with document ownership for self-service updates.
     */
    match /employees/{employeeId} {
      allow get: if isEmployee(employeeId) || isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin() && hasMatchingIdOnCreate(employeeId);
      allow update: if (isEmployee(employeeId) || isAdmin()) && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Secures employee attendance records. Employees can manage their own records; admins can manage any.
     * @path /employees/{employeeId}/attendanceRecords/{attendanceRecordId}
     * @allow An employee (auth.uid='emp_123') can (create) a new attendance record under their own path /employees/emp_123/attendanceRecords/.
     * @deny An employee (auth.uid='emp_123') cannot (get) records for another employee at /employees/emp_456/attendanceRecords/.
     * @principle Enforces data ownership within a user's own data tree and validates relational integrity via the 'employeeId' field.
     */
    match /employees/{employeeId}/attendanceRecords/{attendanceRecordId} {
      allow get: if isEmployee(employeeId) || isAdmin();
      allow list: if isEmployee(employeeId) || isAdmin();
      allow create: if isEmployee(employeeId) || isAdmin();
      allow update: if (isEmployee(employeeId) || isAdmin()) && resource != null;
      allow delete: if (isEmployee(employeeId) || isAdmin()) && resource != null;
    }

    /**
     * @description Secures employee payroll records. Employees can only read their own records; admins have full control.
     * @path /employees/{employeeId}/payrollRecords/{payrollRecordId}
     * @allow An employee (auth.uid='emp_123') can (get) and (list) their own payroll records under /employees/emp_123/payrollRecords/.
     * @deny An employee (auth.uid='emp_123') cannot (create) or (delete) their own payroll records.
     * @principle Provides read-only access for owners while granting full write control to administrators for sensitive data.
     */
    match /employees/{employeeId}/payrollRecords/{payrollRecordId} {
      allow get: if isEmployee(employeeId) || isAdmin();
      allow list: if isEmployee(employeeId) || isAdmin();
      allow create: if isAdmin() && hasMatchingEmployeeIdOnCreate(employeeId);
      allow update: if isAdmin() && resource != null && employeeIdIsImmutable();
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Manages QR codes for employees. Employees can manage their own QR codes; admins can manage any.
     * @path /employees/{employeeId}/qrCodes/{qrCodeId}
     * @allow An employee (auth.uid='emp_123') can (create) a new QR code under their path /employees/emp_123/qrCodes/.
     * @deny An employee (auth.uid='emp_123') cannot (list) QR codes for another employee /employees/emp_456/qrCodes/.
     * @principle Enforces document ownership for both read and write operations within a user's data tree.
     */
    match /employees/{employeeId}/qrCodes/{qrCodeId} {
      allow get: if isEmployee(employeeId) || isAdmin();
      allow list: if isEmployee(employeeId) || isAdmin();
      allow create: if (isEmployee(employeeId) || isAdmin()) && hasMatchingEmployeeIdOnCreate(employeeId);
      allow update: if (isEmployee(employeeId) || isAdmin()) && resource != null && employeeIdIsImmutable();
      allow delete: if (isEmployee(employeeId) || isAdmin()) && resource != null;
    }
  }
}